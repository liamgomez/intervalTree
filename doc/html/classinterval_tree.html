<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Project 7: intervalTree&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Project 7
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Last Project Wooh!</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classinterval_tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">intervalTree&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="interval_tree_8h_source.html">intervalTree.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7d841c11fd9755560bed6f8159ac1a9e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinterval_tree.html#a7d841c11fd9755560bed6f8159ac1a9e">intervalTree</a> ()</td></tr>
<tr class="memdesc:a7d841c11fd9755560bed6f8159ac1a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor for interval tree class  <a href="#a7d841c11fd9755560bed6f8159ac1a9e">More...</a><br/></td></tr>
<tr class="separator:a7d841c11fd9755560bed6f8159ac1a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fa76db3a6fda8e7cdc0c9e84e8bfe2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinterval_tree.html#ae3fa76db3a6fda8e7cdc0c9e84e8bfe2">~intervalTree</a> ()</td></tr>
<tr class="memdesc:ae3fa76db3a6fda8e7cdc0c9e84e8bfe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">default destructor for interval tree class  <a href="#ae3fa76db3a6fda8e7cdc0c9e84e8bfe2">More...</a><br/></td></tr>
<tr class="separator:ae3fa76db3a6fda8e7cdc0c9e84e8bfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651e1272f876a948aea2cca238e24d65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinterval_tree.html#a651e1272f876a948aea2cca238e24d65">destroyTree</a> (<a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *sub)</td></tr>
<tr class="memdesc:a651e1272f876a948aea2cca238e24d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">destroys the tree by preforming a post order deletion  <a href="#a651e1272f876a948aea2cca238e24d65">More...</a><br/></td></tr>
<tr class="separator:a651e1272f876a948aea2cca238e24d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabac1abe00232730c0b93d3cffa39b7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinterval_tree.html#aabac1abe00232730c0b93d3cffa39b7c">insert</a> (const <a class="el" href="classinterval.html">interval</a> input)</td></tr>
<tr class="memdesc:aabac1abe00232730c0b93d3cffa39b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the input interval into new node and puts it into the tree.  <a href="#aabac1abe00232730c0b93d3cffa39b7c">More...</a><br/></td></tr>
<tr class="separator:aabac1abe00232730c0b93d3cffa39b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc282d5871443142bc744cbe1088672"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinterval_tree.html#aabc282d5871443142bc744cbe1088672">getLeftMostNode</a> (<a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *sub)</td></tr>
<tr class="memdesc:aabc282d5871443142bc744cbe1088672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the left most node for a given subtree.  <a href="#aabc282d5871443142bc744cbe1088672">More...</a><br/></td></tr>
<tr class="separator:aabc282d5871443142bc744cbe1088672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03b316e6aff3dc635ac7da1f7ebb13f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinterval_tree.html#ab03b316e6aff3dc635ac7da1f7ebb13f">search</a> (<a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *sub, const <a class="el" href="classinterval.html">interval</a> search)</td></tr>
<tr class="memdesc:ab03b316e6aff3dc635ac7da1f7ebb13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the tree for a given interval.  <a href="#ab03b316e6aff3dc635ac7da1f7ebb13f">More...</a><br/></td></tr>
<tr class="separator:ab03b316e6aff3dc635ac7da1f7ebb13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27113d930450800c9b1e1a5007acebb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinterval_tree.html#a27113d930450800c9b1e1a5007acebb4">searchHelper</a> (const <a class="el" href="classinterval.html">interval</a> <a class="el" href="classinterval_tree.html#ab03b316e6aff3dc635ac7da1f7ebb13f">search</a>)</td></tr>
<tr class="memdesc:a27113d930450800c9b1e1a5007acebb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The recursive helper for the search function.  <a href="#a27113d930450800c9b1e1a5007acebb4">More...</a><br/></td></tr>
<tr class="separator:a27113d930450800c9b1e1a5007acebb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b7653fba7f5df9a242e67e86a2876b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinterval_tree.html#ad2b7653fba7f5df9a242e67e86a2876b">deleteInterval</a> (<a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *target)</td></tr>
<tr class="separator:ad2b7653fba7f5df9a242e67e86a2876b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81787b5ab64d9d3ba1b2f0cf933f98c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinterval_tree.html#aa81787b5ab64d9d3ba1b2f0cf933f98c">fixDelete</a> (<a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *x)</td></tr>
<tr class="separator:aa81787b5ab64d9d3ba1b2f0cf933f98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78c3fec2beba297ab640f0f428e3400"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinterval_tree.html#ae78c3fec2beba297ab640f0f428e3400">swap</a> (<a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *a, <a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *b)</td></tr>
<tr class="memdesc:ae78c3fec2beba297ab640f0f428e3400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple function thats swaps the two nodes a and b.  <a href="#ae78c3fec2beba297ab640f0f428e3400">More...</a><br/></td></tr>
<tr class="separator:ae78c3fec2beba297ab640f0f428e3400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7228084b4c5e95fa2b95849f62e4de02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinterval_tree.html#a7228084b4c5e95fa2b95849f62e4de02">rotateLeft</a> (<a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *x)</td></tr>
<tr class="memdesc:a7228084b4c5e95fa2b95849f62e4de02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates the tree left around the specified x node.  <a href="#a7228084b4c5e95fa2b95849f62e4de02">More...</a><br/></td></tr>
<tr class="separator:a7228084b4c5e95fa2b95849f62e4de02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7597a79aa2d8e24c57d329ac24775e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinterval_tree.html#a1d7597a79aa2d8e24c57d329ac24775e">rotateRight</a> (<a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *x)</td></tr>
<tr class="memdesc:a1d7597a79aa2d8e24c57d329ac24775e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates the tree right around the specified x node.  <a href="#a1d7597a79aa2d8e24c57d329ac24775e">More...</a><br/></td></tr>
<tr class="separator:a1d7597a79aa2d8e24c57d329ac24775e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6577575e3f89b035e6d01f39b1a8081f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinterval_tree.html#a6577575e3f89b035e6d01f39b1a8081f">fixInsertion</a> (<a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *fix)</td></tr>
<tr class="memdesc:a6577575e3f89b035e6d01f39b1a8081f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintains the Red/Black properties of the tree after an insertion.  <a href="#a6577575e3f89b035e6d01f39b1a8081f">More...</a><br/></td></tr>
<tr class="separator:a6577575e3f89b035e6d01f39b1a8081f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755ba72519607da1fa2b64e637f75dfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinterval_tree.html#a755ba72519607da1fa2b64e637f75dfe">fixMaxValues</a> (<a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *x)</td></tr>
<tr class="memdesc:a755ba72519607da1fa2b64e637f75dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the largest max values in a portion of the tree.  <a href="#a755ba72519607da1fa2b64e637f75dfe">More...</a><br/></td></tr>
<tr class="separator:a755ba72519607da1fa2b64e637f75dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f4761ca4516e5bd555c07e2aba86fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinterval_tree.html#a89f4761ca4516e5bd555c07e2aba86fd">overlaps</a> (<a class="el" href="classinterval.html">interval</a> a, <a class="el" href="classinterval.html">interval</a> b)</td></tr>
<tr class="memdesc:a89f4761ca4516e5bd555c07e2aba86fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two intervals (a) and (b) overlap in some form.  <a href="#a89f4761ca4516e5bd555c07e2aba86fd">More...</a><br/></td></tr>
<tr class="separator:a89f4761ca4516e5bd555c07e2aba86fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63459da57b9cd7cc74bcec768200ed6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinterval_tree.html#aa63459da57b9cd7cc74bcec768200ed6">findOverlap</a> (<a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *sub, const <a class="el" href="classinterval.html">interval</a> &amp;target)</td></tr>
<tr class="memdesc:aa63459da57b9cd7cc74bcec768200ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all the overlaps in a given subtree (root)  <a href="#aa63459da57b9cd7cc74bcec768200ed6">More...</a><br/></td></tr>
<tr class="separator:aa63459da57b9cd7cc74bcec768200ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b2a7b7e67b9a46317db8799449ac27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinterval_tree.html#a78b2a7b7e67b9a46317db8799449ac27">overlapHelper</a> (const <a class="el" href="classinterval.html">interval</a> &amp;target)</td></tr>
<tr class="memdesc:a78b2a7b7e67b9a46317db8799449ac27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive helper for the findOverlap function, just uses the root node as the subtree to find all overlap conflicts.  <a href="#a78b2a7b7e67b9a46317db8799449ac27">More...</a><br/></td></tr>
<tr class="separator:a78b2a7b7e67b9a46317db8799449ac27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33734743c5425ab0dfb5146d15116f5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinterval_tree.html#a33734743c5425ab0dfb5146d15116f5f">preorder</a> (<a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *sub)</td></tr>
<tr class="memdesc:a33734743c5425ab0dfb5146d15116f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preorder print function for the interval tree.  <a href="#a33734743c5425ab0dfb5146d15116f5f">More...</a><br/></td></tr>
<tr class="separator:a33734743c5425ab0dfb5146d15116f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197ac6515d25299511a18a69f34a4877"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinterval_tree.html#a197ac6515d25299511a18a69f34a4877">inorderPrint</a> (<a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *sub)</td></tr>
<tr class="memdesc:a197ac6515d25299511a18a69f34a4877"><td class="mdescLeft">&#160;</td><td class="mdescRight">inorder print function for interval tree  <a href="#a197ac6515d25299511a18a69f34a4877">More...</a><br/></td></tr>
<tr class="separator:a197ac6515d25299511a18a69f34a4877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af298a0e4578f0c99ccf93b3ad675e5a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinterval_tree.html#af298a0e4578f0c99ccf93b3ad675e5a2">showTree</a> ()</td></tr>
<tr class="memdesc:af298a0e4578f0c99ccf93b3ad675e5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the tree inorder then in preorder.  <a href="#af298a0e4578f0c99ccf93b3ad675e5a2">More...</a><br/></td></tr>
<tr class="separator:af298a0e4578f0c99ccf93b3ad675e5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br/>
class intervalTree&lt; T &gt;</h3>

<dl class="section note"><dt>Note</dt><dd>uses a template becuase i initially started with my BST imp </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7d841c11fd9755560bed6f8159ac1a9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinterval_tree.html">intervalTree</a>&lt; T &gt;::<a class="el" href="classinterval_tree.html">intervalTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>default constructor for interval tree class </p>
<p>This constructor allocates two nodes, one for the NIL pointer and the other for the root pointer. It sets all the interval and max variables to a very low number to avoid any conflicts. Sets root to NIL to make the tree empty. To maintain RB tree properties the NIL and root nodes both start with the color black.</p>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="ae3fa76db3a6fda8e7cdc0c9e84e8bfe2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classinterval_tree.html">intervalTree</a>&lt; T &gt;::~<a class="el" href="classinterval_tree.html">intervalTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>default destructor for interval tree class </p>
<p>uses the method destroy tree, on the root node to preform a post order deletion of the nodes in the tree.</p>
<dl class="section pre"><dt>Precondition</dt><dd>the program must end </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>the tree will be deleted and the memory returned to the operating system.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad2b7653fba7f5df9a242e67e86a2876b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classinterval_tree.html">intervalTree</a>&lt; T &gt;::deleteInterval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a651e1272f876a948aea2cca238e24d65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classinterval_tree.html">intervalTree</a>&lt; T &gt;::destroyTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>sub</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>destroys the tree by preforming a post order deletion </p>
<p>This function is used in the default destructor for the interval tree class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sub</td><td>The root pointer of the tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="aa63459da57b9cd7cc74bcec768200ed6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classinterval_tree.html">intervalTree</a>&lt; T &gt;::findOverlap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classinterval.html">interval</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all the overlaps in a given subtree (root) </p>
<p>This function recursively goes through the tree finding overlapping intervals, once one is found it is printed using the interval class methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sub</td><td>The subtree to search for overlaps in (initially should be root) </td></tr>
    <tr><td class="paramname">target</td><td>The target interval to search for overlap conflicts with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="aa81787b5ab64d9d3ba1b2f0cf933f98c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classinterval_tree.html">intervalTree</a>&lt; T &gt;::fixDelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6577575e3f89b035e6d01f39b1a8081f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classinterval_tree.html">intervalTree</a>&lt; T &gt;::fixInsertion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>fix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maintains the Red/Black properties of the tree after an insertion. </p>
<p>This function uses five different cases to maintain the Red/black tree properties; Property 3 - All leaves must be black, Property 4</p>
<ul>
<li>Both children of a red node are always black, and Property 5 - All paths from a node to its leaf contain the same number of black nodes</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>Should only be called after the insertion operation is preformed on the tree. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The tree will be fixed, and its RB properties maintained. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fix</td><td>The pointer to the subtree / tree to fix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="a755ba72519607da1fa2b64e637f75dfe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classinterval_tree.html">intervalTree</a>&lt; T &gt;::fixMaxValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the largest max values in a portion of the tree. </p>
<p>This function finds the highest max value from a given subtree, it is used to maintain the max data values throughout insertion / deletion operations. It works by simply looping through the tree comparing max values at each stop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The interval node to find the max value in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="aabc282d5871443142bc744cbe1088672"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classi_node.html">iNode</a>&lt; T &gt; * <a class="el" href="classinterval_tree.html">intervalTree</a>&lt; T &gt;::getLeftMostNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>sub</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the left most node for a given subtree. </p>
<p>Gets the farthest node to the left and returns it, the subtree is usually the root node, but it doesn't matter either way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sub</td><td>The subtree in which to obtain the left most node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interval node that is the farthest left for the given subtree. </dd></dl>

</div>
</div>
<a class="anchor" id="a197ac6515d25299511a18a69f34a4877"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classinterval_tree.html">intervalTree</a>&lt; T &gt;::inorderPrint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>sub</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inorder print function for interval tree </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sub</td><td>The subtree to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="aabac1abe00232730c0b93d3cffa39b7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classinterval_tree.html">intervalTree</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinterval.html">interval</a>&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the input interval into new node and puts it into the tree. </p>
<p>This insertion function first finds the appropriate place for the new node, using the interval low value (i.low) as the key. It then checks the various cases, and prepares the node for insertion fix.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The interval should not already exist in the tree, and should probably not be negative although i haven't tested it.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The new interval will be placed into the tree with no children, and be the color RED to prepare it for insertion fix.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The interval to be inputed into the interval tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="a78b2a7b7e67b9a46317db8799449ac27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classinterval_tree.html">intervalTree</a>&lt; T &gt;::overlapHelper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinterval.html">interval</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursive helper for the findOverlap function, just uses the root node as the subtree to find all overlap conflicts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The interval to search for overlaps in the tree with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="a89f4761ca4516e5bd555c07e2aba86fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classinterval_tree.html">intervalTree</a>&lt; T &gt;::overlaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classinterval.html">interval</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinterval.html">interval</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if two intervals (a) and (b) overlap in some form. </p>
<p>Does a simple comparison to determine if two intervals overlap used to find overlapping intervals in the overlapHelper</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First interval for overlap testing </td></tr>
    <tr><td class="paramname">b</td><td>Second interval for overlap testing</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean result of the test, states if they are overlapping or not. </dd></dl>

</div>
</div>
<a class="anchor" id="a33734743c5425ab0dfb5146d15116f5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classinterval_tree.html">intervalTree</a>&lt; T &gt;::preorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>sub</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Preorder print function for the interval tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sub</td><td>The subtree to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="a7228084b4c5e95fa2b95849f62e4de02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classinterval_tree.html">intervalTree</a>&lt; T &gt;::rotateLeft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates the tree left around the specified x node. </p>
<p>This function will rotate the tree around the interval node x, does not change the order of the elements.</p>
<dl class="section pre"><dt>Precondition</dt><dd>should only be used by fix functions </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The pivot node for which to rotate on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="a1d7597a79aa2d8e24c57d329ac24775e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classinterval_tree.html">intervalTree</a>&lt; T &gt;::rotateRight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates the tree right around the specified x node. </p>
<p>This function will rotate the tree around the interval node x, does not change the order of the elements.</p>
<dl class="section pre"><dt>Precondition</dt><dd>should only be used by fix functions </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The pivot node for which to rotate on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="ab03b316e6aff3dc635ac7da1f7ebb13f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classi_node.html">iNode</a>&lt; T &gt; * <a class="el" href="classinterval_tree.html">intervalTree</a>&lt; T &gt;::search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classinterval.html">interval</a>&#160;</td>
          <td class="paramname"><em>find</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches the tree for a given interval. </p>
<p>This function recursively searches the tree, going either left or right based on the key value.</p>
<dl class="section pre"><dt>Precondition</dt><dd>the subtree to search for the interval should be the root initially, Should only be called using the searchHelper function or bad things will happen.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The given interval will either be found, or a null pointer will be returned.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sub</td><td>The subtree to find the interval in (Should be root!) </td></tr>
    <tr><td class="paramname">find</td><td>The interval to find in the tree</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interval node that contains the target interval </dd></dl>

</div>
</div>
<a class="anchor" id="a27113d930450800c9b1e1a5007acebb4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classi_node.html">iNode</a>&lt; T &gt; * <a class="el" href="classinterval_tree.html">intervalTree</a>&lt; T &gt;::searchHelper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinterval.html">interval</a>&#160;</td>
          <td class="paramname"><em>find</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The recursive helper for the search function. </p>
<p>Simply calls the search function on the root node and returns the found node to caller.</p>
<dl class="section pre"><dt>Precondition</dt><dd>the interval should exist in the tree, if not the caller should force conditions for no run on nullptr return</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">find</td><td>The interval to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interval node that contains the specified interval, nullptr if the interval could not be found. </dd></dl>

</div>
</div>
<a class="anchor" id="af298a0e4578f0c99ccf93b3ad675e5a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classinterval_tree.html">intervalTree</a>&lt; T &gt;::showTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the tree inorder then in preorder. </p>
<p>calls both functions on the root node to display entire tree, also prints the current interval at the root node and color of each node.</p>
<dl class="section pre"><dt>Precondition</dt><dd>the tree should not be empty </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>the interval tree contents will be displayed to the user in both orders.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="ae78c3fec2beba297ab640f0f428e3400"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classinterval_tree.html">intervalTree</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classi_node.html">iNode</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple function thats swaps the two nodes a and b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First interval node to swap </td></tr>
    <tr><td class="paramname">b</td><td>Second interval node to swap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="interval_tree_8h_source.html">intervalTree.h</a></li>
<li><a class="el" href="interval_tree_8cpp.html">intervalTree.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 29 2015 22:05:13 for Project 7 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
